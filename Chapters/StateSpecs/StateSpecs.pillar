!! StateSpec

StateSpecs is object state specification framework. It describes particular object states by first class specifications.
For example there are SpecOfCollectionItem, SpecOfObjectClass and SpecOfObjectSuperclass.
StateSpecs provide readable DSL to validate objects over these specification.

!!! How to load StateSpecs

[[[
Gofer it
   smalltalkhubUser: 'dionisiy' project: '';
   configurationOf: 'StateSpecs';
   loadStable
]]]

!!! Basic

Specifications can match and validate objects. In case when object does not satisfied a specification you will get failure result with detailed information about the problem.
For example try create SpecOfObjectClass and validate objects over it.

[[[
spec := SpecOfObjectClass requiredClass: SmallInteger.
spec validate: 10. "it returns SpecOfValidationSuccess"
spec validate: "some string". "it returns SpecOfValidationFailure which represent error"
]]]

Instead of validation you can simply match objects for specification to get true or false:

[[[
spec matches: 10. "==> true"
spec matches: "string". "==> false"
]]]

To easily create specifications and validate objects by them StateSpecs provides two kind DSL: should expressions and "word" classes.
First allows you to write "assertions":

[[[
1 should be: 2
1 should equal: 10
]]]

And second allows you to instantiate specs by natural readable words:

[[[
Kind of: Number. "==> a SpecOfObjectSuperclass(should be a kind of Number)"
Instance of: String. "==> a SpecOfObjectClass(should be an instance of String)"
Equal to: 'test'. "==> a SpecOfEquality(should equal 'test')"
]]]

Underhood should expression creates particular kind of specification and verify receiver over it.

When object is not valid should expression signals SpecOfFailed error. Then in debugger you can inspect validation result to deeply analyze the reason.


Should expressions were created with the goal to replace SUnit assertions (self assert: a = b). But they can be used anywhere.

Word classes were introduced to get fluent interface for mock object expectations (mock stub someMessage: (Kind of: String)).

But they are very handy shorcuts to work with specifications. For example in Seamless distributed objects framework they are used to specify transfer strategy for set of objects.

!!! Should expressions

[[[
1 should be: 2. "fail with message: Got '1' but it should be '2'"
1 should not be: 1. "fail with message: Got '1' but it should not be '1'"
]]]

[[[
3 should equal: 2. "fail with message: Got '3' but it should equal '2'"
3 should not equal: 3. "fail with message: Got '3' but it should equal '3'"
]]]

[[[
3 should beKindOf: String.
3 should not beKindOf: Number.

3 should beInstanceOf: Number.
3 should not beInstanceOf: SmallInteger.
]]]


[[[
#(1 2) should equal: #(10 20).
#(1 2) should equal: #(1 2) asOrderedCollection. "not fail because by default comparison not look at collection types"
#(1 2) should equal: #(1 2) asSet.
#(1 2) should equal: #(2 1). "not fail because by default equality between collections is not ordered"
#(1 2) should beOrderedEqualTo: #(2 1). "fail because it is explicit requirement for ordered equality"
]]]

[[[
#(1 2) should haveSize: 10.
#(1 2) should include: 10.
#(1 2) should include: 10 at: 1.
#(1 2) should include: (Instance of: String) at: 1.
#(1 2) should include: (Kind of: String) at: 2.
]]]

!!! Raising exception

[[[
[1 + 2] should raise: ZeroDivide.
[1/0] should not raise: ZeroDivide.
[1/0] should raise: Error.
[1/0] should raise: (Kind of: Error).
[1/0] should raiseError.
[self error: 'test'] should raise: errorInstance. "fail because raised error is not the same as expected errorInstance"
[1 + 2] should not raiseError.
]]]

!!! With predicate methods
[[[
3 should be even.
2 should not be even.
]]]

[[[
3 should be between: 10 and: 50.
2 should not between: 1 and: 5.
]]]

[[[
#(1 2) should be isEmpty. "fail with message: #(1 2) should be isEmpty"
#() should not be isEmpty.
]]]

[[[
(1@3 corder: 20@30) where origin x should equal: 100. "fail with message: Got '1' from (1@3 corder: 20@30) origin x but it should equal: 100".
]]]

Look at all expressions in SpecOfShouldExpression class which you can extend with new keywords. SpecOfShouldExpressionTests describes them in tests.

Underhood "should expression" build concrete specification instance and validate subject of should expression by it.

Should expressions signal special SpecOfFailed exception by concrete validation failure. It makes possible to extend debugger tools to better analyse problem. Such tools can be specific for different kind of failures

!!! Conclusion

Is it used in Mocketry?
Mocketry uses StateSpecs to implement specifications of expected behaviour. For exampe it implements SpecOfMessageSend, SpecOfMessageArgument, SpecOfOrderedObjectsInteraction and others.
